---
name: naive-brace-matching
description: НЕ искать { без учёта string literals
alwaysApply: true
---

# Naive Brace Matching

**НЕ ДЕЛАЙ ТАК** — поиск `{` без учёта контекста приводит к ложным срабатываниям.

## Антипаттерн

При парсинге кода нельзя искать `{` как начало блока без проверки, что он не внутри строки.

## Пример из практики

```csharp
// Gherkin паттерн с placeholder
[Then(@"window title should contain {string}")]
public void ThenWindowTitleContains(string expected)
{
    // ...
}
```

```typescript
// ❌ Наивный regex — найдёт { из {string}
const methodBodyStart = content.indexOf('{');
// Результат: парсим "{string})]" как начало тела метода
```

## Последствия

- Неправильное извлечение тела метода
- False positives при валидации
- "ты ваще полную хуету парсишь" — отзыв пользователя

## Как правильно

```typescript
// ✅ Пропускать { внутри строковых литералов
function findMethodBodyStart(content: string, startFrom: number): number {
    let inString = false;
    let stringChar = '';
    
    for (let i = startFrom; i < content.length; i++) {
        const char = content[i];
        
        // Отслеживаем строковые литералы
        if ((char === '"' || char === "'") && content[i-1] !== '\\') {
            if (!inString) {
                inString = true;
                stringChar = char;
            } else if (char === stringChar) {
                inString = false;
            }
        }
        
        // { вне строки = начало блока
        if (char === '{' && !inString) {
            return i;
        }
    }
    return -1;
}
```

## Чеклист

- [ ] При поиске `{` или `}` — отслеживай строковые литералы
- [ ] Учитывай escape-последовательности (`\"`, `\'`)
- [ ] Для C# — учитывай verbatim strings (`@"..."`)
- [ ] Тестируй на коде с Gherkin placeholders
